S = cbind(c(2,-1),c(-1,3))
Sinv = solve(S)
Sinv
Sinv%*%Sinv
Sinv%*%S
x1=rnorm(1000,0,10)
x2=rnorm(1000,0,5)
?loading
?loadings
library(boot)
data(frets)
headsize=frets
colnames(headsize)=c("head1","breadth1","head2","breadth2")
head(headsize)
dim(headsize)
## Show website on length, breadth measurements
pairs(headsize)
round(cor(headsize),2)
hspc=princomp(headsize, cor=TRUE)
summary(hspc)
loadings(hspc)
eigen(cor(headsize))
## First PC explains what % of variation?
eigen(cor(headsize))$values[1]/sum(eigen(cor(headsize))$values)
summary(hspc)
## Spectral representation
eigen(cor(headsize))$vectors%*%diag(eigen(cor(headsize))$values)%*%t(eigen(cor(headsize))$vectors)
cor(headsize)
# standardize the data:
headsize.std=scale(headsize,scale=TRUE);headsize.std=headsize.std[,]
head(headsize.std)
# we will work with the standardized data
# (or equivalently with the correlation matrices of the unstandardized data)
R <- cor(headsize.std)
R
R11 <- R[1:2,1:2]
R11
R12 <- R[1:2,3:4]
R21 <- R[3:4,1:2]
R22 <- R[3:4,3:4]
R11.inv <- solve(R11)
R22.inv <- solve(R22)
# compute E1 and E2
E1 <- R11.inv %*% R12 %*% R22.inv %*% R21
E1
E2 <- R22.inv %*% R21 %*% R11.inv %*% R12
E2
# compute eigenvalues and eigenvectors of E1 and E2:
eigen(E1)
eigen(E2)
# note nonzero eigenvalues are indeed the same and positive
# compute the canonical correlation vectors:
a1 <- eigen(E1)$vectors[,1]
b1 <- eigen(E2)$vectors[,1]
b1=abs(b1) ## Sign is arbitrary, take positive one
# canonical correlations:
sqrt(eigen(E1)$values)
# compute canonical correlation variables:
u1 <- headsize.std[,1:2] %*% a1   # size first son
v1 <- headsize.std[,3:4] %*% b1   # size second son
# check covariance matrix:
cor(u1,v1)
# plot canonical correlation variables:
plot(u1,v1,main="Head size, correlation=0.788", xlab="u1 = 'size' of the 1st son", ylab="v1 = 'size' of the 2nd son")
## Extend to the second canonical correlation
a2 <- eigen(E1)$vectors[,2]
b2 <- eigen(E2)$vectors[,2]
u2 <- headsize.std[,1:2] %*% a2   # shape first son
v2 <- headsize.std[,3:4] %*% b2   # shape second son
par(mfrow=c(1,2))
plot(u1,v1,main="Head size, correlation=0.788", xlab="u1 = 'size' of the 1st son", ylab="v1 = 'size' of the 2nd son")
plot(u2,v2, main="Head shape, correlation=.053", xlab="u2 = 'shape' of the 1st son", ylab="v2 = 'shape' of the 2nd son")
cor(u2,v2)
cc1=cancor(headsize[,1:2],headsize[,3:4])
cc1$cor ## Same as above
## Olympics Example
library(ade4)
library(car)
data(olympic)
Ol=olympic$tab
Os=scale(Ol,scale=TRUE);Os=Os[,]
dim(Os)
round(head(Os),2)
colnames(Os)
Xs=Os[,c(1,5,6,10)]
Ys=Os[,-c(1,5,6,10)]
R <- cor(cbind(Xs,Ys))
round(R,2)
R11 <- R[1:4,1:4]
R12 <- R[1:4,5:10]
R21 <- R[5:10,1:4]
R22 <- R[5:10,5:10]
R11.inv <- solve(R11)
R22.inv <- solve(R22)
# compute E1 and E2
E1 <- R11.inv %*% R12 %*% R22.inv %*% R21
E2 <- R22.inv %*% R21 %*% R11.inv %*% R12
# compute eigenvalues and eigenvectors of E1 and E2:
eigen(E1)
eigen(E2)
a1 <- eigen(E1)$vectors[,1]
b1 <- eigen(E2)$vectors[,1]
# canonical correlations:
sqrt(eigen(E1)$values)
# compute canonical correlation variables:
u1 <- Xs %*% a1   # Running
v1 <- Ys %*% b1   # Non Running
cor(u1,v1)
# check covariance matrix:
round(cor(cbind(u1,v1)),3)
dev.off()
# plot canonical correlation variables:
plot(u1,v1,main="Running and Non-Running", xlab="Running Dataset", ylab="Non-Running Dataset")
## Extend to the second canonical correlation
a2 <- eigen(E1)$vectors[,2]
b2 <- eigen(E2)$vectors[,2]
u2 <- Xs %*% a2
v2 <- Ys %*% b2
par(mfrow=c(1,2))
plot(u1,v1,main="CC 1", xlab="Running Dataset", ylab="Non-Running Dataset")
plot(u2,v2,main="CC 2", xlab="Running Dataset", ylab="Non-Running Dataset")
cor(u1,v1)
cor(u2,v2)
cor(u1,v2) ## basically 0
cor(u1,u2) ## basically 0
cor(v1,v2) ## basically 0
#########################
## Compare academic and psychological datasets
## on 600 students
mm <- read.csv("http://www.ats.ucla.edu/stat/data/mmreg.csv")
colnames(mm) <- c("Control", "Concept", "Motivation", "Read", "Write", "Math",
"Science", "Sex")
mm=mm[,1:7] ## Drop Sex column
psych <- mm[, 1:3]
acad <- mm[, 4:7]
head(psych)
head(acad)
pairs(psych)
pairs(acad)
## Control is the extent to which a person believes they
## can control events around them.
round(cor(mm),2)
#install.packages("ggplot2")
#install.packages("CCA")
#install.packages("GGally")
#library(ggplot2)
install.packages("MVA")
install.packages("ellipse")
library(MVA)
install.packages("HSAUR2")
install.packages("HSAUR2")
install.packages("tools")
install.packages("tools")
install.packages("tools")
install.packages("tools")
setwd("~/Desktop/fall 2016/CSC222/proj1/data")
InsertionSort <- read.table("InsertionSortTimings", header = FALSE, sep = " ")
MergeSort <- read.table("MergeSortTimings", header = FALSE, sep = " ")
QuickSort <- read.table("QuickSortTimings", header = FALSE, sep = " ")
plot(1,type='n',xlim=c(1,dim(InsertionSort)[1]),ylim=c(0, 150),xlab='thousand contacts', ylab='timings(in second)')
plot(1,type='n',xlim=c(1,dim(InsertionSort)[1]),ylim=c(0, 150),xlab='thousand contacts', ylab='timings(in second)', title='Performance')
plot?
plot(1,type='n',xlim=c(1,dim(InsertionSort)[1]),ylim=c(0, 150),xlab='thousand contacts', ylab='timings(in second)', main='Performance')
plot(1,type='n',xlim=c(1,dim(InsertionSort)[1]),ylim=c(0, 150),xlab='thousand contacts', ylab='timings(in second)', main='Performance')
lines(InsertionSort$V2,type='o',col='firebrick',lwd=1)
lines(MergeSort$V2,type='o',col='olivedrab',lwd=1)
lines(QuickSort$V2,type='o',col='grey40',lwd=1)
legend('topleft', c('Insertion', 'Merge', 'Quick') , lty=1, col=c('firebrick', 'olivedrab', 'grey40'), bty='n', cex=.75)
