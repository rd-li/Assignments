1. what are the subproblems? what does a "solution" look like?
    subproblem: will the current position be the end of a legitimate word that starts from a legitimate position?
    solution look like: the last character in the string can be the end of a legitimate word -> the whole string convertible; the last character in the string cannot be the end of a legitimate word -> the whole string is not convertible. Actually as long as there are n continuous characters cannot be the end of a legitimate word, and n is greater than the length of the longest word in the dictionary, then the whole string should be non-convertible.
2. how to solve a subproblem given the solutions to "smaller" subproblems?
    Say we are parsing a string, like "itrainedtoday", after parsing the first two character "it", we can see "i" itself can be a word, "it" together can be a word (since "i" is the very beginning of the string, it's a legitimate start of a word by default). So in the array for taking note of whether this position could be a legitimate start looks like: [True, True] right now. And for the next character "r", we want to find a legitimate start of the word ending with "r". The requirement for a legitimate start position: 1) position 0; 2) the character of the previous position is marked as a legitimate end of a word. So in this case, we can check "r", "tr", and "itr".  
